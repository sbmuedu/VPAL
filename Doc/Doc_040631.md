# Prisam Schema -----
Of course. Here is a comprehensive Prisma schema (`schema.prisma`) for the hospital Electronic Medical Records system we designed.

This schema includes:
1.  All the tables described, with appropriate field types and relations.
2.  Enums for fixed sets of values (like `EncounterType`, `VisitType`).
3.  Autoincrement IDs for simplicity (you can change these to `String` or `uuid()` if desired).
4.  Realistic one-to-many and many-to-one relationships.

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or "mysql", "sqlserver"
  url      = env("DATABASE_URL")
}

enum EncounterType {
  INPATIENT
  OUTPATIENT
  EMERGENCY
}

enum VisitType {
  CLINIC
  EMERGENCY
  HOSPITAL
  URGENT_CARE
  VIRTUAL
  // Add other types as needed
}

model Patient {
  id                      Int         @id @default(autoincrement())
  medicalRecordNumber     String      @unique @map("medical_record_number")
  firstName               String      @map("first_name")
  lastName                String      @map("last_name")
  dateOfBirth             DateTime    @map("date_of_birth") // Use DateTime for precision, even if just date
  gender                  String?     // Could be a relation to a Gender table instead
  genderIdentity          String?     @map("gender_identity")
  ssn                     String?     @db.VarChar(15) // Should be encrypted at the application level
  race                    String?
  ethnicity               String?
  preferredLanguage       String?     @map("preferred_language")
  profilePhotoUrl         String?     @map("profile_photo_url") // Store URL/path, not the image itself

  // Relations
  addresses               PatientAddress[]
  contacts                EmergencyContact[]
  encounters              Encounter[]

  @@map("patients")
  // Timestamps are highly recommended for audit
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
}

model PatientAddress {
  id              Int     @id @default(autoincrement())
  addressType     String  @map("address_type") // e.g., 'HOME', 'WORK'
  streetAddress1  String  @map("street_address_1")
  streetAddress2  String? @map("street_address_2")
  city            String
  stateProvince   String  @map("state_province")
  postalCode      String  @map("postal_code")
  country         String  @default("USA")
  phoneNumber     String? @map("phone_number")
  phoneType       String? @map("phone_type") // e.g., 'MOBILE', 'HOME'
  emailAddress    String? @map("email_address") @db.VarChar(100)

  // Relation
  patient    Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId  Int     @map("patient_id") // Foreign key

  @@map("patient_addresses")
}

model EmergencyContact {
  id               Int     @id @default(autoincrement())
  firstName        String  @map("first_name")
  lastName         String  @map("last_name")
  relationship     String
  phoneNumber      String  @map("phone_number")
  isPrimaryContact Boolean @default(false) @map("is_primary_contact")

  // Relation
  patient    Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId  Int     @map("patient_id") // Foreign key

  @@map("emergency_contacts")
}

model Provider {
  id         Int    @id @default(autoincrement())
  providerNpi String @unique @map("provider_npi") // National Provider Identifier
  firstName  String @map("first_name")
  lastName   String @map("last_name")
  specialty  String?

  // Relations (a Provider can be attached to many encounters, diagnoses, etc.)
  encountersAttended Encounter[] @relation("AttendingPhysician")
  diagnosesMade      Diagnosis[]
  medicationsPrescribed Medication[]
  proceduresPerformed Procedure[]
  notesWritten       ClinicalNote[]

  @@map("providers")
}

model Encounter {
  id                   Int            @id @default(autoincrement())
  encounterType        EncounterType  @map("encounter_type")
  visitType            VisitType      @map("visit_type")
  admissionDateTime    DateTime       @map("admission_date_time")
  dischargeDateTime    DateTime?      @map("discharge_date_time")
  chiefComplaint       String?        @map("chief_complaint") @db.Text
  location             String?        // e.g., "ER Bay 4", "Room 301"
  status               String         // e.g., "TRIAGE", "IN_PROGRESS", "DISCHARGED"

  // Relations
  patient            Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId          Int       @map("patient_id")

  attendingPhysician Provider? @relation("AttendingPhysician", fields: [attendingPhysicianId], references: [id])
  attendingPhysicianId Int?    @map("attending_physician_id")

  // A single Encounter can have many related clinical entities
  diagnoses    Diagnosis[]
  medications  Medication[]
  procedures   Procedure[]
  vitals       VitalSign[]
  labResults   LabResult[]
  clinicalNotes ClinicalNote[]

  @@map("encounters")
}

model Diagnosis {
  id              Int       @id @default(autoincrement())
  icd11Code       String    @map("icd_11_code") // International Classification of Diseases, 11th Revision
  description     String
  type            String    // e.g., "ADMITTING", "FINAL", "DIFFERENTIAL"
  dateDiagnosed   DateTime  @map("date_diagnosed") @default(now())

  // Relations
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId Int       @map("encounter_id")

  diagnosedBy   Provider @relation(fields: [diagnosedById], references: [id])
  diagnosedById Int      @map("diagnosed_by_id")

  @@map("diagnoses")
}

model Medication {
  id           Int       @id @default(autoincrement())
  medicationName String  @map("medication_name")
  dosage       String?
  route        String?   // e.g., "PO", "IV", "TOPICAL"
  frequency    String?
  startDate    DateTime  @map("start_date")
  endDate      DateTime? @map("end_date")

  // Relations
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId Int       @map("encounter_id")

  prescribingPhysician   Provider @relation(fields: [prescribingPhysicianId], references: [id])
  prescribingPhysicianId Int      @map("prescribing_physician_id")

  @@map("medications")
}

model Procedure {
  id           Int       @id @default(autoincrement())
  cptCode      String?   @map("cpt_code") // Current Procedural Terminology code
  description  String
  procedureDateTime DateTime @map("procedure_date_time")

  // Relations
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId Int       @map("encounter_id")

  performingPhysician   Provider @relation(fields: [performingPhysicianId], references: [id])
  performingPhysicianId Int      @map("performing_physician_id")

  @@map("procedures")
}

model VitalSign {
  id                     Int     @id @default(autoincrement())
  recordedDateTime       DateTime @default(now()) @map("recorded_date_time")
  heartRate              Int?     @map("heart_rate") // bpm
  bloodPressureSystolic  Int?     @map("blood_pressure_systolic")
  bloodPressureDiastolic Int?     @map("blood_pressure_diastolic")
  temperature            Float?   // Celsius or Fahrenheit
  respiratoryRate        Int?     @map("respiratory_rate") // breaths per minute
  o2Saturation           Float?   @map("o2_saturation") // Percentage

  // Relations
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId Int       @map("encounter_id")

  @@map("vital_signs")
}

model LabResult {
  id               Int       @id @default(autoincrement())
  orderedDateTime  DateTime? @map("ordered_date_time")
  testName         String    @map("test_name")
  resultValue      String    @map("result_value") // String to accommodate text results like "Positive"
  resultUnit       String?   @map("result_unit")
  referenceRange   String?   @map("reference_range")
  resultDateTime   DateTime  @map("result_date_time") @default(now())

  // Relations
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId Int       @map("encounter_id")

  @@map("lab_results")
}

model ClinicalNote {
  id                   Int      @id @default(autoincrement())
  noteType             String   @map("note_type") // e.g., "PROGRESS_NOTE", "DISCHARGE_SUMMARY"
  noteText             String   @map("note_text") @db.Text
  authoredDateTime     DateTime @map("authored_date_time") @default(now())
  lastModifiedDateTime DateTime @map("last_modified_date_time") @updatedAt

  // Relations
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId Int       @map("encounter_id")

  author   Provider @relation(fields: [authorId], references: [id])
  authorId Int      @map("author_id")

  @@map("clinical_notes")
}
```

### Important Notes on This Schema:

1.  **Database Provider:** The `datasource db` block is set to `postgresql` as it's a common choice for complex applications. You can change it to `mysql` or `sqlserver`.

2.  **Field Names:** Uses `@map` to use snake_case in the database (a common convention) while allowing you to use camelCase in your Prisma client code.

3.  **Cascading Deletes:** The `onDelete: Cascade` directive is used on many foreign keys. This means if a `Patient` or `Encounter` is deleted, all their related records (addresses, medications, etc.) will also be deleted. **This is a very destructive operation and might not be desired in a production medical system for audit reasons.** A better alternative is **soft deletes** (adding an `isDeleted` boolean field), but that logic must be implemented in your application, not the database schema.

4.  **Encryption:** Sensitive fields like `ssn` are marked with a comment to encrypt them **at the application level** before storing them in the database. Prisma itself does not handle encryption.

5.  **Timestamps:** Added `createdAt` and `updatedAt` to the `Patient` model as an example. It is highly recommended to add these audit fields to almost all your models.

6.  **Enums vs. Strings:** `EncounterType` and `VisitType` are defined as Enums for strict control. Other fields like `gender` or `addressType` are left as Strings for flexibility, but you could also create Enums or related tables for them.

7.  **NPI for Providers:** The `Provider` model uses an NPI number, which is a standard US identifier for healthcare providers.

To use this schema:
1.  Save it as `schema.prisma`.
2.  Set the `DATABASE_URL` in your `.env` file.
3.  Run `npx prisma generate` to generate the client.
4.  Run `npx prisma db push` (for prototyping) or `npx prisma migrate dev` (for proper migrations) to create the tables in your database.
# Additional data for VP ----
Of course. This is a fantastic use case. The schema we designed is a great foundation, but for an educational virtual patient system, we need to extend it significantly to handle scenarios, student actions, scoring, and supervisor feedback.

We'll need to create new tables to manage these educational concepts while reusing the core patient data tables.

Here is the enhanced Prisma schema, followed by a breakdown of how it all works together for education.

### Enhanced Prisma Schema for Virtual Patient Education

```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ... [Keep all previous Enums and Models: Patient, PatientAddress, EmergencyContact, Provider, Encounter, Diagnosis, Medication, Procedure, VitalSign, LabResult, ClinicalNote] ...

// 1. NEW: Store the patient's ongoing medical history and allergies
model MedicalHistory {
  id          Int      @id @default(autoincrement())
  patient     Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId   Int      @map("patient_id")
  description String   @db.Text
  type        String   // e.g., 'SURGICAL', 'CHRONIC', 'FAMILY', 'ALLERGY'
  severity    String?  // e.g., 'MILD', 'MODERATE', 'SEVERE' (especially for allergies)
  onsetDate   DateTime? @map("onset_date")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("medical_histories")
}

// 2. NEW: The Core of the Education System - Scenario Definition
model Scenario {
  id                      Int       @id @default(autoincrement())
  title                   String
  description             String?   @db.Text
  difficulty              String    // e.g., 'BEGINNER', 'INTERMEDIATE', 'ADVANCED'
  chiefComplaint          String    @map("chief_complaint") @db.Text
  initialVitalsJson       String?   @map("initial_vitals_json") @db.Text // JSON string of initial vitals
  initialPresentation     String?   @map("initial_presentation") @db.Text // Initial narrative for the student

  // A scenario is built around a specific virtual patient
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientId Int     @map("patient_id")

  // A scenario defines a list of correct actions and expected outcomes
  expectedActions    ExpectedAction[]
  expectedOutcomes   ExpectedOutcome[]
  studentSimulations StudentSimulation[]

  isActive    Boolean @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("scenarios")
}

// 3. NEW: Defines a correct action within a scenario (e.g., "Order CBC", "Prescribe Amoxicillin")
model ExpectedAction {
  id          Int      @id @default(autoincrement())
  scenario    Scenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  scenarioId  Int      @map("scenario_id")
  actionType  String   @map("action_type") // e.g., 'ORDER_LAB', 'PRESCRIBE_MED', 'ORDER_IMAGING', 'PERFORM_PROCEDURE', 'MAKE_DIAGNOSIS'
  description String   // Human-readable description of the expected action
  parameters  String?  @db.Text // JSON to define details (e.g., { "labTest": "CBC" } or { "medicationId": 5 } )
  points      Int      @default(0) // Points awarded for performing this action
  isCritical  Boolean  @default(false) @map("is_critical") // Is this a must-do action?

  @@map("expected_actions")
}

// 4. NEW: Defines an expected outcome (e.g., "Heart rate should decrease", "O2 Sat should improve")
model ExpectedOutcome {
  id                 Int      @id @default(autoincrement())
  scenario           Scenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  scenarioId         Int      @map("scenario_id")
  description        String
  vitalSign          String?  @map("vital_sign") // e.g., 'heartRate'
  expectedChange     String?  @map("expected_change") // e.g., 'DECREASE', 'INCREASE', 'NORMALIZE'
  timeFromStartMinutes Int?   @map("time_from_start_minutes") // When should this outcome be checked?
  points             Int      @default(0) // Points awarded if outcome is met

  @@map("expected_outcomes")
}

// 5. NEW: A student's attempt at a scenario
model StudentSimulation {
  id                Int       @id @default(autoincrement())
  scenario          Scenario  @relation(fields: [scenarioId], references: [id])
  scenarioId        Int       @map("scenario_id")
  studentId         String    @map("student_id") // ID from your user/auth system
  studentName       String    @map("student_name")

  // The central encounter for this simulation attempt
  encounter         Encounter @relation(fields: [encounterId], references: [id])
  encounterId       Int       @map("encounter_id")

  startTime         DateTime  @default(now()) @map("start_time")
  endTime           DateTime? @map("end_time")
  status            String    @default("IN_PROGRESS") // e.g., 'IN_PROGRESS', 'COMPLETED', 'ABANDONED'
  totalScore        Int       @default(0) @map("total_score")

  // Log all actions and supervisor interactions
  studentActions    StudentAction[]
  supervisorComments SupervisorComment[]
  vitalLogs         SimulationVitalLog[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([scenarioId, studentId, encounterId])
  @@map("student_simulations")
}

// 6. NEW: Logs every action a student takes during a simulation
model StudentAction {
  id          Int      @id @default(autoincrement())
  simulation  StudentSimulation @relation(fields: [simulationId], references: [id], onDelete: Cascade)
  simulationId Int     @map("simulation_id")
  actionType  String   @map("action_type") // Matches ExpectedAction.actionType
  description String   // What the student actually did
  parameters  String?  @db.Text // JSON of the action details
  timestamp   DateTime @default(now())
  // Link this action to a concrete record in the EMR, if applicable
  relatedMedicationId Int? @map("related_medication_id")
  relatedLabResultId  Int? @map("related_lab_result_id")
  relatedProcedureId  Int? @map("related_procedure_id")
  relatedDiagnosisId  Int? @map("related_diagnosis_id")

  // Was this action correct? (Can be auto-checked against ExpectedAction)
  isCorrect   Boolean? @map("is_correct")
  pointsAwarded Int?   @default(0) @map("points_awarded")

  @@map("student_actions")
}

// 7. NEW: Logs the state of the patient's vitals over time during the simulation
model SimulationVitalLog {
  id            Int      @id @default(autoincrement())
  simulation    StudentSimulation @relation(fields: [simulationId], references: [id], onDelete: Cascade)
  simulationId  Int      @map("simulation_id")
  timestamp     DateTime @default(now())
  heartRate              Int?
  bloodPressureSystolic  Int?
  bloodPressureDiastolic Int?
  temperature            Float?
  respiratoryRate        Int?
  o2Saturation           Float?

  // Computed field: minutes since simulation started
  // This would be calculated in your application logic, not stored in the DB.

  @@map("simulation_vital_logs")
}

// 8. NEW: Allows a supervisor to give feedback and potentially penalize the student
model SupervisorComment {
  id           Int      @id @default(autoincrement())
  simulation   StudentSimulation @relation(fields: [simulationId], references: [id], onDelete: Cascade)
  simulationId Int      @map("simulation_id")
  supervisorId String   @map("supervisor_id")
  comment      String   @db.Text
  pointsDelta  Int      @default(0) @map("points_delta") // e.g., -5 for a mistake pointed out
  createdAt    DateTime @default(now()) @map("created_at")

  @@map("supervisor_comments")
}
```

---

### How the Educational Logic Works (The "Game Plan")

1.  **Scenario Setup:**
    *   An instructor **creates a `Scenario`** (e.g., "45yo male with chest pain").
    *   They select or create a **virtual `Patient`** with a full `MedicalHistory` (e.g., history of hypertension, smoker).
    *   They define the `chiefComplaint` and initial `initialVitalsJson` (e.g., elevated heart rate and BP).
    *   They list all `ExpectedAction`s (e.g., "Order ECG", "Prescribe Nitroglycerin", "Diagnose Myocardial Infarction") and assign `points` and `isCritical` flags.
    *   They define `ExpectedOutcome`s (e.g., "ST segment elevation on ECG", "Chest pain resolves after nitro").

2.  **Student Attempt:**
    *   A student **selects a scenario**. Your application creates:
        1.  A new `StudentSimulation` record.
        2.  A new `Encounter` for that patient (linking the virtual patient to this simulation attempt).
    *   The student interacts with the virtual patient through a UI that mimics an EMR.
    *   Every interaction (**ordering a lab, prescribing a drug**) is recorded as a `StudentAction` and simultaneously creates a real record in the `Medication`, `LabResult`, etc., tables, linking it to the `Encounter`. This keeps the medical record consistent.

3.  **Automated Scoring & Dynamic Vitals:**
    *   **Action Scoring:** After a `StudentAction` is logged, the backend can **automatically compare** it against the list of `ExpectedAction`s for the scenario.
        *   If it matches, `isCorrect` is set to `true`, and `pointsAwarded` is set.
        *   Incorrect or harmful actions can be given negative points.
    *   **Vital Changes:** The application has a **state engine** that knows how medications and procedures should affect vitals.
        *   *Example:* If a student prescribes a beta-blocker (records a `Medication` and a `StudentAction`), the system's logic will schedule a gradual decrease in heart rate and blood pressure.
        *   The `SimulationVitalLog` table is periodically updated (e.g., every simulated 5 minutes) to reflect these changes, creating a timeline of the patient's state.
    *   **Outcome Scoring:** At the end of the simulation, the system can check the `ExpectedOutcome`s against the final `SimulationVitalLog` and clinical data (`Diagnosis`, `LabResult`) to award points.

4.  **Supervisor Intervention:**
    *   A supervisor (instructor) can watch a student's progress in real-time or review it later.
    *   They can add a `SupervisorComment` to provide teaching points.
    *   The `pointsDelta` field allows them to manually adjust the score (e.g., "-10 for missing a critical diagnosis" or "+5 for excellent bedside manner noted in a note").

5.  **Debriefing:**
    *   The student's final report is a combination of:
        *   Their `totalScore`.
        *   A timeline of all their `StudentAction`s, color-coded by correctness.
        *   The `SupervisorComment`s.
        *   A graph of the `SimulationVitalLog` showing how their actions affected the patient.

This schema provides a powerful and flexible foundation for building a realistic and educationally valuable virtual patient simulation platform. The key is writing the application logic that connects these tablesâ€”the "rules of the game" that dictate how student actions change the patient's state.
# ----
# ----
# ----
# ----
# ----
# ----
# ----
# ----
# ----
# ----
# ----
